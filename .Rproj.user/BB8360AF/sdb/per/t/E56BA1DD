{
    "collab_server" : "",
    "contents" : "## useful-fn.R\n\n## Convert SAS period to date\nsasperiod.date <- function(x) format(as.Date(x, origin=\"1960-01-01\"))\n\n## lag a variable by a group (e.g. firm-year)\n\nget.dd <- function(lm.object){\n  lm.dd <- lm.object\n  dd.results <- data.frame(matrix(NA, nrow=3, ncol=3))\n  row.names(dd.results) <- c(\"Treatment\", \"Control\", \"Diff\")\n  names(dd.results) <- c(\"Post-treatment\", \"Pre-treatment\", \"Diff\")\n  b0 <- lm.dd$coefficients[[\"(Intercept)\"]]\n  b1 <- lm.dd$coefficients[[\"I(post * treated)\"]]\n  b2 <- lm.dd$coefficients[[\"treated\"]]\n  b3 <- lm.dd$coefficients[[\"post\"]]\n  \n  dd.results[\"Treatment\", \"Post-treatment\"] <- b0+b1+b2+b3\n  dd.results[\"Treatment\", \"Pre-treatment\"] <- b0+b2\n  dd.results[\"Treatment\", \"Diff\"] <- b1+b3\n  \n  dd.results[\"Control\", \"Post-treatment\"] <- b0+b3\n  dd.results[\"Control\", \"Pre-treatment\"] <- b0\n  dd.results[\"Control\", \"Diff\"] <- b3\n  \n  dd.results[\"Diff\", \"Post-treatment\"] <- b1+b2\n  dd.results[\"Diff\", \"Pre-treatment\"] <- b2\n  dd.results[\"Diff\", \"Diff\"] <- b1\n  \n  return(dd.results)\n}\n\n## winsorize\nwins <- function(x){\n  percentiles <- quantile(x, probs=seq(0,1,0.01), na.rm=TRUE)\n  p01 <- percentiles[\"1%\"]\n  p99 <- percentiles[\"99%\"]\n  x.w <- ifelse(x<=p01, p01, x)\n  x.w <- ifelse(x>=p99, p99, x.w)\n  return(x.w)\n}\nwins.df <- function(X, var, firmid=\"firm\", yearid = \"year\", append.wins.label = FALSE){\n  years <- unique(X[,yearid])\n  Y <- X\n  for(year in years){\n    x <- X[which(X[, yearid] == year), var]\n    x.w <- wins(x)\n    var.w <- var\n    if(append.wins.label) var.w <- paste(var, \".w\", sep=\"\")\n    Y[which(Y[,yearid] == year), var.w] <- x.w\n  }\n  print(summary(Y[,var.w]))\n  print(summary(X[,var]))\n  return(Y)\n}\n\n## Usage:\n##\n## > for(x in vars){\n## >   X1 <- wins.df(X[,c(\"gvkey\", \"fyear\", x)], var=x, firmid=\"gvkey\", yearid=\"fyear\" )\n## >   X <- merge(X, X1, by=c(\"gvkey\", \"fyear\"))  \n## > }\n\n## Summary statistics\nget.summary.stats.helper <- function(x){\n  p01 <- quantile(x, probs=seq(0, 1, .01), na.rm=TRUE)[\"1%\"]\n  p05 <- quantile(x, probs=seq(0, 1, .01), na.rm=TRUE)[\"5%\"]\n  p25 <- quantile(x, probs=seq(0, 1, .01), na.rm=TRUE)[\"25%\"]\n  p75 <- quantile(x, probs=seq(0, 1, .01), na.rm=TRUE)[\"75%\"]\n  p95 <- quantile(x, probs=seq(0, 1, .01), na.rm=TRUE)[\"95%\"]\n  p99 <- quantile(x, probs=seq(0, 1, .01), na.rm=TRUE)[\"99%\"]\n  s <- c(mean(x, na.rm=TRUE), sd(x, na.rm=TRUE), p01, p05, p25, median(x, na.rm=TRUE), p75, p95, p99, trunc(length(x)), trunc(length(which(is.na(x)))))\n  return(formatC(s, format=\"f\", digits=3, big.mark=\",\"))\n}\nget.summary.stats <- function(df, variables){\n  summary.stats <- data.frame(matrix(NA, nrow=0, ncol=9))\n  names(summary.stats) <- c(\"Mean\", \"Std Dev\", \"1st\", \"5th\", \"25th\", \"Median\", \"75th\", \"95th\", \"99th\")\n  for(v in variables) summary.stats[v, ] <- get.summary.stats.helper(df[,v])\n  return(summary.stats)\n}\nget.summary.stats2 <- function(df, variables){\n  summary.stats <- data.frame(matrix(NA, nrow=0, ncol=11))\n  names(summary.stats) <- c(\"Mean\", \"Std Dev\", \"1st\", \"5th\", \"25th\", \"Median\", \"75th\", \"95th\", \"99th\", \"N\", \"NMISS\")\n  for(v in variables) summary.stats[v, ] <- get.summary.stats.helper(df[,v])\n  return(summary.stats)\n}\n\n## Usage:\n## > \n\n# x is a matrix containing the data\n# method : correlation method. \"pearson\"\" or \"spearman\"\" is supported\n# removeTriangle : remove upper or lower triangle\n# results :  if \"html\" or \"latex\"\n# the results will be displayed in html or latex format\ncorstars <- function(x, method=c(\"pearson\", \"spearman\"), removeTriangle=c(\"upper\", \"lower\"),\n                    result=c(\"none\", \"html\", \"latex\")){\n  #Compute correlation matrix\n  require(Hmisc)\n  x <- as.matrix(x)\n  correlation_matrix<-rcorr(x, type=method[1])\n  R <- correlation_matrix$r # Matrix of correlation coeficients\n  p <- correlation_matrix$P # Matrix of p-value \n  \n  ## Define notions for significance levels; spacing is important.\n  mystars <- ifelse(p < .001, \"****\", ifelse(p < .001, \"*** \", ifelse(p < .01, \"**  \", ifelse(p < .05, \"*   \", \"    \"))))\n  \n  ## trunctuate the correlation matrix to two decimal\n  R <- format(round(cbind(rep(-1.11, ncol(x)), R), 2))[,-1]\n  \n  ## build a new matrix that includes the correlations with their apropriate stars\n  Rnew <- matrix(paste(R, mystars, sep=\"\"), ncol=ncol(x))\n  diag(Rnew) <- paste(diag(R), \" \", sep=\"\")\n  rownames(Rnew) <- colnames(x)\n  colnames(Rnew) <- paste(colnames(x), \"\", sep=\"\")\n  \n  ## remove upper triangle of correlation matrix\n  if(removeTriangle[1]==\"upper\"){\n    Rnew <- as.matrix(Rnew)\n    Rnew[upper.tri(Rnew, diag = TRUE)] <- \"\"\n    Rnew <- as.data.frame(Rnew)\n  }\n  \n  ## remove lower triangle of correlation matrix\n  else if(removeTriangle[1]==\"lower\"){\n    Rnew <- as.matrix(Rnew)\n    Rnew[lower.tri(Rnew, diag = TRUE)] <- \"\"\n    Rnew <- as.data.frame(Rnew)\n  }\n  \n  ## remove last column and return the correlation matrix\n  Rnew <- cbind(Rnew[1:length(Rnew)-1])\n  if (result[1]==\"none\") return(Rnew)\n  else{\n    if(result[1]==\"html\") print(xtable(Rnew), type=\"html\")\n    else print(xtable(Rnew), type=\"latex\") \n  }\n} \n\n## Get different quantiles grouped by year\n## Default is quinties\n## df is data frame you want to have bucketed\n## by.group is grouping variable (e.g. year)\n## x is variable to be bucketed\n## outputs df with quantile label appended\nget.quantiles <- function(df, by.group, x, g = 5){\n  by.group <- deparse(substitute(by.group))\n  x <- deparse(substitute(x))\n  out.name <- paste(x, 'quint', sep='')\n  groups <- unique(df[,by.group])\n  \n  for(j in 1:length(groups)){\n    i <- which(df[, by.group] == groups[j])\n    \n    df.quintiles <- quantile(df[i, x], probs = seq(0,1, 1/g), na.rm = TRUE)\n    group.cuts <- cut(df[i, x], breaks = df.quintiles, include.lowest = TRUE, labels = FALSE)\n    df[i, out.name] <- group.cuts\n  }\n  df <- df[order(df[, by.group], df[, x]), ]\n  return(df)  \n}\n\nget.quantiles2 <- function(df, by.group, x, g = 5){\n  if(g == 5) out.name <- paste(x, 'quintile', sep='.')\n  if(g == 10) out.name <- paste(x, 'decile', sep='.')\n  if(g == 4) out.name <- paste(x, 'quartile', sep='.')\n  \n  groups <- unique(df[,by.group])\n  \n  for(j in 1:length(groups)){\n    i <- which(df[, by.group] == groups[j])\n    \n    df.quantiles <- quantile(df[i, x], probs = seq(0,1, 1/g), na.rm = TRUE)\n    ## jitter\n    df.quantiles <- df.quantiles + rnorm(length(df.quantiles), 0, .001)\n    group.cuts <- cut(df[i, x], breaks = df.quantiles, include.lowest = TRUE, labels = FALSE)\n    df[i, out.name] <- group.cuts\n  }\n  df <- df[order(df[, by.group], df[, x]), ]\n  return(df)  \n}\n\n## Moving averages\nma <- function(x, n=4){filter(x,rep(1/n,n), sides=2)}\n\n## lag a variable by a group (e.g. firm-year)\n## dataframe must be properly sorted first\nlg <- function(x){ \n  n <- length(x)\n  if(n < 2){\n    y <- NA\n  }else{\n    y <- c(NA, x[1:(n-1)]) \n  }\n  return(y)\n}\n\nld <- function(x){\n  n <- length(x)\n  if(n <2){\n    y <- NA\n  }else{\n    y <- c(x[2:n], NA) \n  }\n  return(y)\n}\n\nlead.df <- function(dt, x, by.group, time.var){\n  x.lead <- unlist(tapply(X = dt[, x], INDEX = dt[, by.group], FUN = ld))\n  dt.out <- dt\n  dt.out[, paste(x, 'lead1', sep = '.')] <- x.lead\n  \n  ## sort the dataframe that is to be returned to the user by its group and \n  ## appropriate (user-defined and user-sorted) time variable\n  dt.out <- dt.out[order(dt.out[, by.group], dt.out[, time.var]), ]\n  return(dt.out)\n}\n\nlag.df <- function(dt, x, by.group, time.var){\n  x.lag <- unlist(tapply(X = dt[, x], INDEX = dt[, by.group], FUN = lg))\n  dt.out <- dt\n  dt.out[, paste(x, 'lag1', sep = '.')] <- x.lag\n  \n  ## sort the dataframe that is to be returned to the user by its group and \n  ## appropriate (user-defined and user-sorted) time variable\n  dt.out <- dt.out[order(dt.out[, by.group], dt.out[, time.var]), ]\n  return(dt.out)\n}\n\ntest.lag.df <- function(){\n  by.group <- \"group\"\n  time.var <- \"time\"\n  x <- \"X1\"\n  dt = data.frame(matrix(rnorm(40), nrow = 20))\n  dt$group <- rep(c(1:5),4)\n  dt$time <- rep(101:104, 5)\n  dt[21, ] <- dt[20, ]\n  dt[22, ] <- dt[19, ]\n  dt[21, 'group'] <- 6\n  dt[22, 'group'] <- 1.5\n  dt <- dt[order(dt$group, dt$time), ]\n  lag.df2(dt, \"X2\", \"group\", \"time\")\n  lead.df(dt, \"X1\", \"group\", \"time\")\n}\n\nlag.variable <- function(dt, x, by.group){\n  ## TODO: Remove group members with only one observation\n  group.counts <- aggregate(dt)\n  return(unlist(tapply(X = dt[, x], INDEX = dt[, by.group], FUN = lg)))\n}\n\nlead.variable <- function(dt, x, by.group){\n  ## TODO: Remove group members with only one observation\n  return(unlist(tapply(X = dt[, x], INDEX = dt[, by.group], FUN = ld)))\n}\n\n## Convert month to quarter\nmonth.to.quarter <- function(m) return(ceiling(m/3))\n\n## map lm names to different printed values\nmap.names.lm <- function(m, in.names, out.names){\n  ## m is an lm object\n  ## in.names is a character vector of names currently in lm object\n  ## out.names is a character vector of names to be output\n  ## Note: in.names and out.names must align\n  #if(length(in.names) != length(out.names)) break\n  model.coeffs <- names(m$coefficients)\n  for(i in 1:length(in.names)){\n    o <- which(model.coeffs == in.names[i])\n    if(length(o) > 0) model.coeffs[o] <- out.names[i]\n  }\n  names(m$coefficients) <- model.coeffs\n  return(m)\n}\n\n## get impact of cross-sectional regression\nxs.impact <- function(df, v, m){\n  X <- df\n  ## Cross-Sec impacts\n  #v <- 'p_unc_terms'\n  ## first decile of variable\n  v.decile1 <- quantile(X[, v], probs = seq(0,1,.1))[['10%']]\n  ## tenth decile of variable\n  v.decile10 <- quantile(X[, v], probs = seq(0,1,.1))[['100%']]\n  ## regression coefficient\n  v.coeff <- m$coefficients[[v]]\n  ## c.p. impact\n  v.impact <- (v.decile10 - v.decile1)*v.coeff\n  \n  return(v.impact)\n}\n\n## Industry classifications\nsource('/Users/Reginald/Dropbox/Research/0_code/ff48.R')\n",
    "created" : 1528765678399.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "7|30|30|0|\n",
    "hash" : "3270572853",
    "id" : "E56BA1DD",
    "lastKnownWriteTime" : 1529194345,
    "last_content_update" : 1529194345613,
    "path" : "C:/Users/Reginald/Dropbox/Research/0_code/useful-fn.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}